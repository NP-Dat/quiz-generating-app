[
  {
    "question": "What is an environment variable in Linux?",
    "answers": [
      "A dynamic named value affecting process behavior",
      "A static configuration file for users",
      "A file stored in /etc/environment",
      "A hardware-level setting"
    ],
    "correct_answer": 0
  },
  {
    "question": "Which environment variable tells the shell where to look for commands?",
    "answers": ["PATH", "HOME", "SHELL", "USER"],
    "correct_answer": 0
  },
  {
    "question": "How does a child process inherit environment variables?",
    "answers": [
      "Automatically from its parent via fork()",
      "By reloading /etc/profile",
      "Through the kernel’s boot table",
      "Only through sudo execution"
    ],
    "correct_answer": 0
  },
  {
    "question": "When execve() runs a new program, what happens to old environment variables?",
    "answers": [
      "They are replaced by the new process’s environment",
      "They persist until reboot",
      "They are written to /tmp/env",
      "They are automatically encrypted"
    ],
    "correct_answer": 0
  },
  {
    "question": "In execve(), which argument is used to pass environment variables?",
    "answers": ["Third argument (envp)", "First argument", "Second argument", "Environment block file"],
    "correct_answer": 0
  },
  {
    "question": "What command lists all current environment variables in Linux?",
    "answers": ["env", "lsenv", "getenviron", "ps -e"],
    "correct_answer": 0
  },
  {
    "question": "Which global variable allows a process to access its environment outside main()?",
    "answers": ["environ", "argv", "argc", "pathenv"],
    "correct_answer": 0
  },
  {
    "question": "What is the purpose of the /proc/<pid>/environ file?",
    "answers": [
      "It contains the environment variables of a running process",
      "It logs all executed shell commands",
      "It stores system boot parameters",
      "It lists shared memory segments"
    ],
    "correct_answer": 0
  },
  {
    "question": "How can you display your current process’s environment variables using /proc?",
    "answers": [
      "strings /proc/$$/environ",
      "cat /proc/env",
      "grep env /proc/self",
      "echo $PROCENV"
    ],
    "correct_answer": 0
  },
  {
    "question": "Shell variables differ from environment variables because they:",
    "answers": [
      "Exist only within the current shell and are not inherited by child processes",
      "Are stored in /etc/profile",
      "Are always global across sessions",
      "Require root privileges"
    ],
    "correct_answer": 0
  },
  {
    "question": "When typing 'env' in a shell, what process actually runs?",
    "answers": [
      "A child process of the shell prints the environment",
      "The shell itself reprints variables",
      "A kernel daemon is executed",
      "The /etc/environment file is read directly"
    ],
    "correct_answer": 0
  },
  {
    "question": "Why are environment variables part of a program’s attack surface?",
    "answers": [
      "Users can modify them before execution, affecting privileged programs",
      "They are automatically network-shared",
      "They cannot be modified once set",
      "They are read-only in Set-UID context"
    ],
    "correct_answer": 0
  },
  {
    "question": "What does dynamic linking use environment variables for?",
    "answers": [
      "To locate and load shared libraries at runtime",
      "To store user passwords",
      "To manage CPU scheduling",
      "To configure syslog behavior"
    ],
    "correct_answer": 0
  },
  {
    "question": "Which command shows the shared libraries used by a program?",
    "answers": ["ldd <program>", "lslib", "libscan", "dynlib --list"],
    "correct_answer": 0
  },
  {
    "question": "What does the LD_PRELOAD variable do?",
    "answers": [
      "Specifies libraries to load before all others",
      "Disables dynamic linking",
      "Forces all programs to run with root privileges",
      "Caches libraries for faster booting"
    ],
    "correct_answer": 0
  },
  {
    "question": "What is the purpose of LD_LIBRARY_PATH?",
    "answers": [
      "Specifies directories to search for shared libraries",
      "Lists libraries currently loaded",
      "Contains library permissions",
      "Defines kernel module paths"
    ],
    "correct_answer": 0
  },
  {
    "question": "Why can LD_PRELOAD and LD_LIBRARY_PATH be dangerous for Set-UID programs?",
    "answers": [
      "They can cause malicious libraries to be loaded with root privileges",
      "They delete system files on execution",
      "They disable kernel modules",
      "They overwrite environment variables permanently"
    ],
    "correct_answer": 0
  },
  {
    "question": "How does the dynamic linker mitigate LD_PRELOAD attacks in Set-UID programs?",
    "answers": [
      "It ignores LD_* variables when real and effective UIDs differ",
      "It encrypts all libraries",
      "It blocks execve() calls",
      "It logs and resets PATH values"
    ],
    "correct_answer": 0
  },
  {
    "question": "In OS X 10.10, the DYLD_PRINT_TO_FILE vulnerability allowed:",
    "answers": [
      "Writing to protected files using Set-UID processes",
      "Bypassing login authentication",
      "Disabling SIP security",
      "Escalating privileges via cronjobs"
    ],
    "correct_answer": 0
  },
  {
    "question": "A Set-UID program that calls system() is unsafe because:",
    "answers": [
      "system() invokes a shell that uses environment variables like PATH",
      "It disables logs",
      "It ignores signals",
      "It always runs as root"
    ],
    "correct_answer": 0
  },
  {
    "question": "Which system call is recommended for securely executing external programs?",
    "answers": ["execve()", "system()", "bash -c", "popen()"],
    "correct_answer": 0
  },
  {
    "question": "Compared to system(), execve() is safer because:",
    "answers": [
      "It does not use a shell and ignores user-supplied environment variables",
      "It logs all inputs",
      "It requires administrator approval",
      "It disables output buffering"
    ],
    "correct_answer": 0
  },
  {
    "question": "What is the primary attack vector of environment variables?",
    "answers": [
      "Hidden dependency in privileged program behavior",
      "Memory overflow on startup",
      "Network misconfiguration",
      "Incorrect group ownership"
    ],
    "correct_answer": 0
  },
  {
    "question": "Which library subsystem is affected by LANG and LC_MESSAGES environment variables?",
    "answers": ["Locale subsystem", "Dynamic linker", "Authentication module", "File descriptor table"],
    "correct_answer": 0
  },
  {
    "question": "Locale-related environment variable misuse can lead to which vulnerability?",
    "answers": [
      "Format string vulnerabilities in printf()",
      "Privilege escalation through LD_PRELOAD",
      "Buffer overflow in execve()",
      "Race condition in /tmp"
    ],
    "correct_answer": 0
  },
  {
    "question": "Which secure function should replace getenv() in privileged programs?",
    "answers": ["secure_getenv()", "safe_env()", "getenv_s()", "env_check()"],
    "correct_answer": 0
  },
  {
    "question": "How does secure_getenv() differ from getenv()?",
    "answers": [
      "It returns NULL when secure execution is required (e.g., in Set-UID context)",
      "It decrypts environment variables before returning",
      "It always returns lowercase values",
      "It filters only PATH variables"
    ],
    "correct_answer": 0
  },
  {
    "question": "Which attack occurs when a program copies environment variable values into fixed-size buffers without validation?",
    "answers": [
      "Buffer overflow via environment variable",
      "Race condition",
      "Privilege dropping",
      "Injection via system()"
    ],
    "correct_answer": 0
  },
  {
    "question": "The 'service approach' is considered safer than Set-UID because:",
    "answers": [
      "Environment variables are not controlled by unprivileged users",
      "It disables logging",
      "It executes all programs remotely",
      "It removes kernel interaction"
    ],
    "correct_answer": 0
  },
  {
    "question": "Which statement best describes the Set-UID approach?",
    "answers": [
      "Normal users run special programs that temporarily gain root privileges",
      "It permanently assigns root rights to all users",
      "It limits execution to one user only",
      "It disables execve()"
    ],
    "correct_answer": 0
  },
  {
    "question": "Why does Android remove the Set-UID mechanism?",
    "answers": [
      "To minimize attack surfaces from environment variables",
      "To reduce file system size",
      "To simplify file permissions",
      "To improve UI responsiveness"
    ],
    "correct_answer": 0
  },
  {
    "question": "In attacks via external programs, why is system() more dangerous than execve()?",
    "answers": [
      "system() uses /bin/sh, which interprets environment variables and user input",
      "It always opens network ports",
      "It replaces process credentials",
      "It changes process ID"
    ],
    "correct_answer": 0
  },
  {
    "question": "What can an attacker achieve by changing the PATH variable before running a Set-UID program?",
    "answers": [
      "Execute a malicious program instead of the intended system binary",
      "Delete all PATH entries permanently",
      "Change kernel routing",
      "Bypass password hashing"
    ],
    "correct_answer": 0
  },
  {
    "question": "Why is LD_PRELOAD ignored in Set-UID binaries by the linker?",
    "answers": [
      "To prevent loading untrusted user libraries with elevated privileges",
      "Because it slows execution",
      "Because root libraries are immutable",
      "Because PATH is fixed"
    ],
    "correct_answer": 0
  },
  {
    "question": "When using dynamic linking, static linking is safer because:",
    "answers": [
      "It embeds libraries into the executable, avoiding environment-based injection",
      "It disables file logging",
      "It reduces memory use",
      "It prevents fork()"
    ],
    "correct_answer": 0
  },
  {
    "question": "Which attack surface grows when privileged programs rely on external libraries that read environment variables?",
    "answers": [
      "Library attack surface",
      "Kernel attack surface",
      "Network attack surface",
      "User interface attack surface"
    ],
    "correct_answer": 0
  },
  {
    "question": "What is a safe development practice for handling environment variables in privileged code?",
    "answers": [
      "Sanitize or ignore untrusted environment variables before use",
      "Trust default values set by the shell",
      "Log all environment variables for debugging",
      "Copy all to /tmp/env_backup"
    ],
    "correct_answer": 0
  },
  {
    "question": "In Linux, which command can show both effective and real UIDs for a running process?",
    "answers": ["id", "whoami", "env", "echo $UID"],
    "correct_answer": 0
  },
  {
    "question": "An attacker exploiting getenv() in a Set-UID binary can:",
    "answers": [
      "Control program behavior or cause buffer overflow",
      "Bypass sudo authentication",
      "Modify kernel boot parameters",         
      "Crash the init process"
    ],
    "correct_answer": 0
  },
  {
    "question": "In environment variable attacks, what principle should developers always apply?",
    "answers": [
      "Least privilege and input sanitization",
      "Default root execution",
      "Inherit all variables",
      "Never drop privileges"
    ],
    "correct_answer": 0
  }
]
